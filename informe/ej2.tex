\section{Problema 2: Horizontes lejanos}

\subsection{Presentaci\'on del problema}
%aca ponemos una interpretacion de lo que nos pide el enunciado y algunas aclaraciones de como vamos a encarar el problema.
Dado un conjunto de rectángulos en un plano, todos apoyados sobre una linea recta horizontal, como en las siguientes figuras, se pide eliminar las líneas que colisionen con algún otro rectángulo, donde colisionar también es sólamente ``tocar'' otra línea.
\begin{figure}[ht]
	\begin{minipage}[t]{0.5\linewidth}
		\centering
		\includegraphics[width=\textwidth]{p1_ej1_pre.jpg}
		\caption{Con colisión total}
		\label{fig:p1_ej1_pre}
	\end{minipage}
	\begin{minipage}[t]{0.5\linewidth}
		\centering
		\includegraphics[width=\textwidth]{p1_ej2_pre.jpg}
		\caption{Sólo se tocan los bordes}
		\label{fig:p1_ej2_pre}
	\end{minipage}
\end{figure}

\noindent Así, tras ejecutar el algoritmo, el resultado para los ejemplos anteriores sería:

\begin{figure}[ht]
	\begin{minipage}[t]{0.5\linewidth}
		\centering
		\includegraphics[width=\textwidth]{p1_ej1_post.jpg}
		\caption{Resultado con colisión total}
		\label{fig:p1_ej1_post}
	\end{minipage}
	\begin{minipage}[t]{0.5\linewidth}
		\centering
		\includegraphics[width=\textwidth]{p1_ej2_post.jpg}
		\caption{Resultado cuando sólo se tocan los bordes}
		\label{fig:p1_ej2_post}
	\end{minipage}
\end{figure}

Como requerimiento adicional, el algoritmo para $n$ rectángulos debe tener una complejidad temporal estrictamente menor que $O(n^2)$.

\subsection{Resoluci\'on}
\subsubsection{Algoritmo}
Como introducción al pseudocódigo de nuestra implementación describiremos las ideas que lo respaldan para facilitar 
la asimilación del mismo. El algoritmo es muy simple pero tiene un par de puntos sutiles sobre los
que vale la pena hacer hincapié. A grandes rasgos se basa en los siguientes puntos:
\begin{enumerate}
	\item divide a los edificios en eventos de apertura y cierre
	\item ordena los eventos convenientemente
	\item itera el conjunto de eventos y va a agregando a su solución parcial los puntos en los que
	identifica cambios de altura (forma en la que definimos los puntos del contorno)
\end{enumerate} 
Cada edificio se representa con un evento de apertura y uno de cierre. Los dos eventos van a compartir la altura
original del edificio pero van a diferir en la coordenada $x$ que van a llevar: uno se quedará con la correspondiente
al inicio del edificio y el otro con la correspondiente a la finalización del mismo. 
El orden es más fácil pensarlo como una suerte de Radix Sort. Primero se ordena los eventos por su coordenada
$x$. Luego entre, entre los que comparten su coordenada $x$ , se deja primero a los eventos de apertura y luego
a los de cierre. Finalmente, entre los que comparten coordenada $x$ y tipo, se ordena: en orden decreciente de altura
a los de tipo apertura y en orden creciente a los de tipo cierre. Vamos a mostrar la conveniencia de este orden
mostrando casos en los que traería problemas si estuvieran desordenados con respecto al criterio que recién describimos:
\begin{itemize}
	\item desordenados con respecto a $x$: 
\end{itemize}
\subsubsection{Pseudoc\'odigo}
%aca va el pseudocodigo del problema.
\begin{algorithm}[H]
\begin{algorithmic}
\STATE $eventos$ $\gets$ extraer\_eventos($edificios$)
\STATE $contorno_parcial$ $\gets$ $secuencia_vacia$
\STATE $h_{actual}$ $\gets$ 0
\WHILE {$eventos$ $\neq$ $\emptyset$}
	\STATE $ev$ $\gets$ proximo\_evento($eventos$)
	\IF {abre($ev$)}
		\IF {$h_{actual}$ $<$ $ev_h$}
			\STATE $h_{actual}$ $\gets$ $ev_h$
			\STATE AgregarAtrás($<ev_x, ev_h>$, $contornoParcial$)
		\ENDIF
	\ELSE
		\IF {$h_{actual}$ = $ev_h$ $\land$ maxAbierto($ev_x$) $<$ $h_{actual}$}
			\STATE $h_{actual}$ = maxAbierto($ev_x$)
			\STATE AgregarAtrás($<ev_x, h_{actual}>$, $contorno_parcial$)  
		\ENDIF
	\ENDIF
\ENDWHILE
\caption{horizontes\_lejanos}
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\begin{algorithmic}
	\STATE $min_x$ = min( $\{ ev_x | ev \in eventos\}$ )
	\STATE $comparten\_min_x$ = $\{ ev \in eventos | ev_x = min_x \}$
	\IF {quedanEventosDeApertura($comparten\_min_x$)}
		\STATE $comparten\_min_x$ = filtrarLosDeCierre($comparten\_min_x$)
		\RETURN mayorAltura($comparten\_min_x$)
	\ELSE
		\RETURN menorAltura($comparten\_min_x$)
	\ENDIF
\caption{proximo\_evento}
\end{algorithmic}
\end{algorithm}

\subsection{Demostraci\'on}
\input{p2_demo_correctitud}

\subsection{An\'alisis de complejidad}
%aca decimos cuanto cuesta cada parte del algoritmo y damos un valor final de la complejidad del algoritmo, ej O(logn).

\subsection{Test de complejidad}
%aca van los graficos y todos los testeos que hagamos para probar que en la practica el algoritmo cumple la complejidad que propusimos en el punto anterior

\subsection{Testing}
%aca ponermos todos nuestros casos bordes, como actua nuestro algoritmo en los casos particulares.































