\section{Problema 2: Horizontes lejanos}

\subsection{Presentaci\'on del problema}
%aca ponemos una interpretacion de lo que nos pide el enunciado y algunas aclaraciones de como vamos a encarar el problema.
Dado un conjunto de rectángulos en un plano, todos apoyados sobre una linea recta horizontal, como en las siguientes figuras, se pide eliminar las líneas que colisionen con algún otro rectángulo, donde colisionar también es sólamente ``tocar'' otra línea.
\begin{figure}[ht]
	\begin{minipage}[t]{0.5\linewidth}
		\centering
		\includegraphics[width=\textwidth]{p1_ej1_pre.jpg}
		\caption{Con colisión total}
		\label{fig:p1_ej1_pre}
	\end{minipage}
	\begin{minipage}[t]{0.5\linewidth}
		\centering
		\includegraphics[width=\textwidth]{p1_ej2_pre.jpg}
		\caption{Sólo se tocan los bordes}
		\label{fig:p1_ej2_pre}
	\end{minipage}
\end{figure}

\noindent Así, tras ejecutar el algoritmo, el resultado para los ejemplos anteriores sería:

\begin{figure}[ht]
	\begin{minipage}[t]{0.5\linewidth}
		\centering
		\includegraphics[width=\textwidth]{p1_ej1_post.jpg}
		\caption{Resultado con colisión total}
		\label{fig:p1_ej1_post}
	\end{minipage}
	\begin{minipage}[t]{0.5\linewidth}
		\centering
		\includegraphics[width=\textwidth]{p1_ej2_post.jpg}
		\caption{Resultado cuando sólo se tocan los bordes}
		\label{fig:p1_ej2_post}
	\end{minipage}
\end{figure}

Como requerimiento adicional, el algoritmo para $n$ rectángulos debe tener una complejidad temporal estrictamente menor que $O(n^2)$.

\subsection{Resoluci\'on}
\subsubsection{Algoritmo}
%aca ponemos una descripcion de nuestro algoritmo, presentamos la variables las estructuras y decimos que hacemos.
COMPLETAR

\subsubsection{Pseudoc\'odigo}
%aca va el pseudocodigo del problema.
\begin{algorithm}[H]
\begin{algorithmic}
\STATE $eventos$ $\gets$ extraer\_eventos($edificios$)
\STATE $contorno_parcial$ $\gets$ $secuencia_vacia$
\STATE $h_{actual}$ $\gets$ 0
\WHILE {$eventos$ $\neq$ $\emptyset$}
	\STATE $ev$ $\gets$ proximo\_evento($eventos$)
	\IF {abre($ev$)}
		\IF {$h_{actual}$ $<$ $ev_h$}
			\STATE $h_{actual}$ $\gets$ $ev_h$
			\STATE AgregarAtrás($<ev_x, ev_h>$, $contornoParcial$)
		\ENDIF
	\ELSE
		\IF {$h_{actual}$ = $ev_h$ $\land$ maxAbierto($ev_x$) $<$ $h_{actual}$}
			\STATE $h_{actual}$ = maxAbierto($ev_x$)
			\STATE AgregarAtrás($<ev_x, h_{actual}>$, $contorno_parcial$)  
		\ENDIF
	\ENDIF
\ENDWHILE
\caption{horizontes\_lejanos}
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\begin{algorithmic}
	\STATE $min_x$ = min( $\{ ev_x | ev \in eventos\}$ )
	\STATE $comparten\_min_x$ = $\{ ev \in eventos | ev_x = min_x \}$
	\IF {quedanEventosDeApertura($comparten\_min_x$)}
		\STATE $comparten\_min_x$ = filtrarLosDeCierre($comparten\_min_x$)
		\RETURN mayorAltura($comparten\_min_x$)
	\ELSE
		\RETURN menorAltura($comparten\_min_x$)
	\ENDIF
\caption{proximo\_evento}
\end{algorithmic}
\end{algorithm}

\subsection{Demostraci\'on}
\input{p2_demo_correctitud}

\subsection{An\'alisis de complejidad}
%aca decimos cuanto cuesta cada parte del algoritmo y damos un valor final de la complejidad del algoritmo, ej O(logn).

\subsection{Test de complejidad}
%aca van los graficos y todos los testeos que hagamos para probar que en la practica el algoritmo cumple la complejidad que propusimos en el punto anterior

\subsection{Testing}
%aca ponermos todos nuestros casos bordes, como actua nuestro algoritmo en los casos particulares.































